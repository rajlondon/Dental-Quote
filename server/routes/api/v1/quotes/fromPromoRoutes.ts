import { Router, Request, Response } from 'express';
import express from 'express';
import { db } from '../../../../db';
import * as schema from "@shared/schema";
import { eq, and, isNotNull } from 'drizzle-orm';
import { z } from 'zod';

// Simple middleware for requiring authentication
const isAuthenticated = (req: Request, res: Response, next: express.NextFunction) => {
  if (req.isAuthenticated()) {
    return next();
  }
  return res.status(401).json({
    success: false,
    message: 'Authentication required'
  });
};

// Use fully qualified schema references instead of destructuring
// to avoid conflict with direct database access

// Error handler helper function
const catchAsync = (fn: (req: Request, res: Response, next: express.NextFunction) => Promise<any>) => {
  return (req: Request, res: Response, next: express.NextFunction) => {
    Promise.resolve(fn(req, res, next)).catch(next);
  };
};

// Validation schema for the request
const createQuoteFromPromoSchema = z.object({
  token: z.string().min(3).max(100),
  visitorEmail: z.string().email().optional(),
});

export const fromPromoRouter = Router();

// Create a quote from a promo token
fromPromoRouter.post('/', catchAsync(async (req: Request, res: Response) => {
  // Validate request data
  const validation = createQuoteFromPromoSchema.safeParse(req.body);
  if (!validation.success) {
    return res.status(400).json({
      success: false,
      message: 'Invalid request data',
      errors: validation.error.format(),
    });
  }

  const { token, visitorEmail } = validation.data;

  // First, check if the token exists in the promo_tokens table
  const [promoToken] = await db
    .select()
    .from(schema.promoTokens)
    .where(eq(schema.promoTokens.token, token));

  if (!promoToken) {
    return res.status(404).json({
      success: false,
      message: 'Promotion token not found',
    });
  }

  try {
    // Create timestamp for the database operations
    const timestamp = new Date();
    
    // Find a default patient ID for anonymous quotes
    const [defaultPatient] = await db
      .select()
      .from(schema.users)
      .where(eq(schema.users.email, 'anonymous@mydentalfly.com'))
      .limit(1);
      
    const anonymousPatientId = defaultPatient?.id || 1; // Fallback to ID 1 if not found
    
    // Insert the quote with temporary patient ID - will be reassigned when claimed
    const [insertedQuote] = await db.insert(schema.quotes).values({
      patientId: anonymousPatientId, // Required by schema, will be updated when claimed
      clinicId: String(promoToken.clinicId), // Convert to string to match schema
      status: 'promo_draft', // Special status for promo-generated quotes
      totalPrice: "0", // Will be calculated later when treatments are added
      currency: 'GBP',
      promoToken: token, // Store the promo token used
      source: 'promo', // Mark as coming from a promotion
      // UUID will be auto-generated by the database
      // createdAt and updatedAt will be set automatically by defaultNow()
    }).returning();
    
    // Get the generated quoteId for further use
    const quoteId = insertedQuote.id;
    
    // If visitor provided an email, store it in the promo_quote_visitors table
    if (visitorEmail) {
      await db.insert(schema.promoQuoteVisitors).values({
        quoteId: quoteId,
        email: visitorEmail,
        promoToken: token,
        // createdAt and updatedAt will be set automatically by defaultNow()
      });
    }

    // For initial implementation, just create an empty quote
    // Later versions will add default treatments based on the promo type

    // For promo tokens, we won't create notifications here
    // Notifications will be handled by the patient portal when the patient logs in
    // This is because we need to associate the notification with a user account

    // Return the quote ID
    return res.status(201).json({
      success: true,
      quoteId,
      message: 'Quote created successfully',
      clinicId: promoToken.clinicId,
      promoType: promoToken.promoType,
    });
  } catch (error) {
    console.error('Error creating quote from promo token:', error);
    return res.status(500).json({
      success: false,
      message: 'Failed to create quote from promo token',
    });
  }
}));

// Get quotes created with a specific promo token - admin or clinic only
fromPromoRouter.get('/by-token/:token', isAuthenticated, catchAsync(async (req: Request, res: Response) => {
  const user = req.user;
  
  if (!user || (user.role !== 'admin' && user.role !== 'clinic')) {
    return res.status(403).json({
      success: false,
      message: 'Unauthorized access',
    });
  }

  const { token } = req.params;

  // Get all quotes created with this token
  const quotesWithToken = await db
    .select()
    .from(schema.quotes)
    .where(eq(schema.quotes.promoToken, token))
    .orderBy(schema.quotes.createdAt);

  return res.status(200).json({
    success: true,
    quotes: quotesWithToken,
  });
}));

// Get all quotes created with any promo token - admin only
fromPromoRouter.get('/all', isAuthenticated, catchAsync(async (req: Request, res: Response) => {
  const user = req.user;
  
  if (!user || user.role !== 'admin') {
    return res.status(403).json({
      success: false,
      message: 'Unauthorized access',
    });
  }

  // Get all quotes with promo tokens
  const quotesWithTokens = await db
    .select()
    .from(schema.quotes)
    .where(
      and(
        isNotNull(schema.quotes.promoToken) // Only get quotes with non-null promo tokens
      )
    )
    .orderBy(schema.quotes.createdAt);

  return res.status(200).json({
    success: true,
    quotes: quotesWithTokens,
  });
}));

export default fromPromoRouter;