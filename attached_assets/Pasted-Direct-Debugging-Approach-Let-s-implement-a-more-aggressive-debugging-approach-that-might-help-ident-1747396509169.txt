Direct Debugging Approach
Let's implement a more aggressive debugging approach that might help identify the issue:

// Add this to the QuickQuoteIsolated.tsx file

// 1. Add console logs for component lifecycle
useEffect(() => {
  console.log('[MOUNT] QuickQuoteIsolated component mounted');
  
  return () => {
    console.log('[UNMOUNT] QuickQuoteIsolated component unmounted');
  };
}, []);

// 2. Add a ref to track treatments through renders
const treatmentsRef = useRef(selectedTreatments);
useEffect(() => {
  console.log('[STATE CHANGE] Treatments changed:', {
    previous: treatmentsRef.current,
    current: selectedTreatments,
    same: treatmentsRef.current === selectedTreatments
  });
  treatmentsRef.current = selectedTreatments;
}, [selectedTreatments]);

// 3. Monitor all state changes
useEffect(() => {
  console.log('[STATE SNAPSHOT]', {
    selectedTreatments: selectedTreatments.map(t => t.id),
    promoCode: appliedPromoCode,
    discount,
    timestamp: new Date().toISOString()
  });
}, [selectedTreatments, appliedPromoCode, discount]);

// 4. Replace the applyPromoCode function with this more verbose version
const applyPromoCode = async () => {
  if (!promoCode.trim()) {
    toast.error('Please enter a promo code');
    return;
  }
  
  // Log before any state changes
  console.log('[PROMO START] Before applying promo:', {
    selectedTreatments: selectedTreatments.map(t => ({id: t.id, name: t.name})),
    treatmentCount: selectedTreatments.length,
    promoCode
  });
  
  // Store treatments in multiple ways to track potential issues
  const treatmentsCopy = [...selectedTreatments];
  const treatmentIds = selectedTreatments.map(t => t.id);
  
  setIsApplyingPromo(true);
  
  try {
    console.log('[PROMO APPLYING] Applying code:', promoCode);
    
    // Simulate API call with detailed logging
    const response = await new Promise((resolve, reject) => {
      console.log('[PROMO API] Making API call...');
      
      setTimeout(() => {
        console.log('[PROMO API] API response received');
        
        // Check treatments still exist
        console.log('[PROMO API] Treatments check:', {
          originalCount: treatmentsCopy.length,
          currentCount: selectedTreatments.length,
          treatmentIds,
          currentIds: selectedTreatments.map(t => t.id)
        });
        
        if (promoCode.toUpperCase() === 'DENTAL10') {
          resolve({
            success: true,
            discountType: 'percentage',
            discountValue: 10
          });
        } else if (promoCode.toUpperCase() === 'SMILE20') {
          resolve({
            success: true,
            discountType: 'fixed',
            discountValue: 20
          });
        } else {
          reject(new Error('Invalid promo code'));
        }
      }, 500);
    });
    
    // Calculate discount
    const subtotalBeforeDiscount = selectedTreatments.reduce((sum, t) => sum + t.price, 0);
    console.log('[PROMO DISCOUNT] Calculating discount:', {
      subtotal: subtotalBeforeDiscount,
      response,
      treatmentCount: selectedTreatments.length
    });
    
    let calculatedDiscount = 0;
    if (response.discountType === 'percentage') {
      calculatedDiscount = (subtotalBeforeDiscount * response.discountValue / 100);
    } else if (response.discountType === 'fixed') {
      calculatedDiscount = response.discountValue;
    }
    
    // Ensure discount doesn't exceed subtotal
    calculatedDiscount = Math.min(calculatedDiscount, subtotalBeforeDiscount);
    
    console.log('[PROMO SUCCESS] About to update state:', {
      newDiscount: calculatedDiscount,
      newPromoCode: promoCode,
      currentTreatments: selectedTreatments.length,
      originalTreatments: treatmentsCopy.length
    });
    
    // Explicitly preserve treatments while updating other state
    setAppliedPromoCode(promoCode);
    setDiscount(calculatedDiscount);
    setPromoCode('');
    
    // Force preservation of treatments if they were somehow lost
    if (selectedTreatments.length === 0 && treatmentsCopy.length > 0) {
      console.log('[PROMO RECOVERY] Treatments were lost! Restoring from backup');
      setSelectedTreatments(treatmentsCopy);
    }
    
    // Show success message with a delay
    setTimeout(() => {
      console.log('[PROMO TOAST] Showing success toast, treatments:', selectedTreatments.length);
      toast.success(`Promo code applied! Discount: $${calculatedDiscount.toFixed(2)}`);
    }, 100);
    
  } catch (error) {
    console.error('[PROMO ERROR]', error);
    toast.error(error.message || 'Failed to apply promo code');
  } finally {
    console.log('[PROMO FINALLY] Resetting loading state, treatments:', selectedTreatments.length);
    setIsApplyingPromo(false);
  }
};
Extreme Measures to Try
If you can modify the QuickQuoteIsolated.tsx file with these additional debugging logs, please also try these extreme measures:

Disable React StrictMode: Look for <React.StrictMode> in your main index.tsx or App.tsx file and temporarily remove it

Force-preserve treatments: Add this effect to the component:

// Force preservation of treatments
const preservedTreatmentsRef = useRef<Treatment[]>([]);
useEffect(() => {
  if (selectedTreatments.length > 0) {
    preservedTreatmentsRef.current = [...selectedTreatments];
  }
}, [selectedTreatments]);

useEffect(() => {
  // Check if treatments were lost after any state change
  const timeoutId = setTimeout(() => {
    if (selectedTreatments.length === 0 && preservedTreatmentsRef.current.length > 0) {
      console.log('[RECOVERY] Treatments were lost! Restoring from preserved ref');
      setSelectedTreatments([...preservedTreatmentsRef.current]);
    }
  }, 50);
  
  return () => clearTimeout(timeoutId);
});
Try a completely different state management approach: Replace useState with useReducer:

const initialState = {
  selectedTreatments: [],
  appliedPromoCode: null,
  discount: 0,
  isApplyingPromo: false
};

function reducer(state, action) {
  switch (action.type) {
    case 'TOGGLE_TREATMENT':
      const exists = state.selectedTreatments.some(t => t.id === action.treatment.id);
      return {
        ...state,
        selectedTreatments: exists 
          ? state.selectedTreatments.filter(t => t.id !== action.treatment.id)
          : [...state.selectedTreatments, action.treatment]
      };
    case 'APPLY_PROMO_START':
      return {
        ...state,
        isApplyingPromo: true
      };
    case 'APPLY_PROMO_SUCCESS':
      return {
        ...state,
        appliedPromoCode: action.code,
        discount: action.discount,
        isApplyingPromo: false
      };
    case 'APPLY_PROMO_ERROR':
      return {
        ...state,
        isApplyingPromo: false
      };
    case 'REMOVE_PROMO':
      return {
        ...state,
        appliedPromoCode: null,
        discount: 0
      };
    default:
      return state;
  }
}