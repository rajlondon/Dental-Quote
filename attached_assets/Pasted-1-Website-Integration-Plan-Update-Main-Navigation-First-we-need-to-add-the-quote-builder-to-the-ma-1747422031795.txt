1. Website Integration Plan
Update Main Navigation
First, we need to add the quote builder to the main navigation:

// client/src/components/MainNavigation.tsx
export function MainNavigation() {
  return (
    <nav className="main-navigation">
      {/* Existing navigation items */}
      <NavItem 
        to="/quote" 
        icon={<CalculatorIcon />} 
        label="Treatment Quote" 
      />
    </nav>
  );
}
Add Quote Builder to Homepage
We should also add a prominent call-to-action on the homepage:

// client/src/pages/HomePage.tsx
<section className="cta-section">
  <h2>Plan Your Dental Treatment</h2>
  <p>Get an instant quote for your dental procedures with our easy-to-use quote builder.</p>
  <Button as={Link} to="/quote" variant="primary" size="large">
    Build Your Quote
  </Button>
</section>
Update Treatment Pages
Add quote links to individual treatment pages:

// client/src/components/treatments/TreatmentDetail.tsx
export function TreatmentDetail({ treatment }) {
  const { addTreatmentToQuote } = useQuoteStore();
  
  return (
    <div className="treatment-detail">
      {/* Existing treatment details */}
      
      <div className="treatment-actions">
        <Button 
          onClick={() => {
            addTreatmentToQuote(treatment);
            // Navigate to quote page
            navigate('/quote');
          }}
        >
          Add to Quote
        </Button>
      </div>
    </div>
  );
}
2. Portal Integration Plan
Patient Portal Integration
We need to add a quotes section to the patient portal:

// client/src/pages/patient/PatientPortal.tsx
import { QuotesList } from '../../components/quotes/QuotesList';

export function PatientPortal() {
  const { user } = useAuth();
  
  return (
    <div className="patient-portal">
      {/* Existing portal content */}
      
      <section className="quotes-section">
        <h2>Your Treatment Quotes</h2>
        <QuotesList patientId={user.id} />
        
        <div className="action-buttons">
          <Button as={Link} to="/quote" variant="primary">
            Create New Quote
          </Button>
        </div>
      </section>
    </div>
  );
}
Create QuotesList Component
// client/src/components/quotes/QuotesList.tsx
import { useState, useEffect } from 'react';
import { formatDate } from '../../utils/date-formatter';
import { formatCurrency } from '../../utils/currency-formatter';

export function QuotesList({ patientId, clinicId }) {
  const [quotes, setQuotes] = useState([]);
  const [loading, setLoading] = useState(true);
  const [error, setError] = useState(null);
  
  useEffect(() => {
    async function fetchQuotes() {
      try {
        setLoading(true);
        
        // Different endpoints based on whether it's patient or clinic
        const endpoint = patientId 
          ? `/api/quotes/patient/${patientId}`
          : `/api/quotes/clinic/${clinicId}`;
          
        const response = await fetch(endpoint);
        
        if (!response.ok) {
          throw new Error('Failed to fetch quotes');
        }
        
        const data = await response.json();
        setQuotes(data.quotes);
      } catch (err) {
        console.error('Error fetching quotes:', err);
        setError('Unable to load your quotes. Please try again later.');
      } finally {
        setLoading(false);
      }
    }
    
    fetchQuotes();
  }, [patientId, clinicId]);
  
  if (loading) {
    return <div className="loading">Loading your quotes...</div>;
  }
  
  if (error) {
    return <div className="error-message">{error}</div>;
  }
  
  if (quotes.length === 0) {
    return (
      <div className="empty-state">
        <p>You don't have any quotes yet.</p>
        <Button as={Link} to="/quote">Create Your First Quote</Button>
      </div>
    );
  }
  
  return (
    <div className="quotes-list">
      {quotes.map(quote => (
        <div key={quote.id} className="quote-card">
          <div className="quote-header">
            <h3>Quote #{quote.id}</h3>
            <span className="quote-date">{formatDate(quote.createdAt)}</span>
          </div>
          
          <div className="quote-summary">
            <p>{quote.treatments.length} treatments</p>
            <p className="quote-total">{formatCurrency(quote.total)}</p>
          </div>
          
          <div className="quote-actions">
            <Button as={Link} to={`/quotes/${quote.id}`} variant="outline">
              View Details
            </Button>
            <Button as={Link} to={`/quotes/${quote.id}/print`} variant="ghost">
              Print
            </Button>
          </div>
        </div>
      ))}
    </div>
  );
}
Clinic Portal Integration
Similarly, add quotes to the clinic portal:

// client/src/pages/clinic/ClinicPortal.tsx
import { QuotesList } from '../../components/quotes/QuotesList';

export function ClinicPortal() {
  const { clinic } = useClinic();
  
  return (
    <div className="clinic-portal">
      {/* Existing portal content */}
      
      <section className="patient-quotes">
        <h2>Patient Quotes</h2>
        <QuotesList clinicId={clinic.id} />
      </section>
    </div>
  );
}
3. Server-Side Integration
Create Necessary API Endpoints
// server/routes/quotes.ts
import { Router } from 'express';
import { authenticateUser, authorizeRoles } from '../middleware/auth';

const router = Router();

// Get quotes for a patient
router.get('/patient/:patientId', authenticateUser, async (req, res) => {
  try {
    const { patientId } = req.params;
    
    // Ensure users can only access their own quotes
    if (req.user.id !== patientId && !req.user.roles.includes('admin')) {
      return res.status(403).json({ error: 'Unauthorized access' });
    }
    
    const quotes = await req.storage.getQuotesByPatientId(patientId);
    
    res.json({ quotes });
  } catch (error) {
    console.error('Error fetching patient quotes:', error);
    res.status(500).json({ error: 'Failed to fetch quotes' });
  }
});

// Get quotes for a clinic
router.get('/clinic/:clinicId', authenticateUser, authorizeRoles(['clinic_staff', 'admin']), async (req, res) => {
  try {
    const { clinicId } = req.params;
    
    // Ensure clinic staff can only access their own clinic's quotes
    if (req.user.clinicId !== clinicId && !req.user.roles.includes('admin')) {
      return res.status(403).json({ error: 'Unauthorized access' });
    }
    
    const quotes = await req.storage.getQuotesByClinicId(clinicId);
    
    res.json({ quotes });
  } catch (error) {
    console.error('Error fetching clinic quotes:', error);
    res.status(500).json({ error: 'Failed to fetch quotes' });
  }
});

// Get a specific quote by ID
router.get('/:quoteId', authenticateUser, async (req, res) => {
  try {
    const { quoteId } = req.params;
    const quote = await req.storage.getQuoteById(quoteId);
    
    if (!quote) {
      return res.status(404).json({ error: 'Quote not found' });
    }
    
    // Ensure users can only access their own quotes or clinic staff can access their clinic's quotes
    if (
      req.user.id !== quote.patientId && 
      req.user.clinicId !== quote.clinicId && 
      !req.user.roles.includes('admin')
    ) {
      return res.status(403).json({ error: 'Unauthorized access' });
    }
    
    res.json({ quote });
  } catch (error) {
    console.error('Error fetching quote:', error);
    res.status(500).json({ error: 'Failed to fetch quote' });
  }
});

// Save a new quote
router.post('/', authenticateUser, async (req, res) => {
  try {
    const { patientInfo, treatments, promoCode, discountPercent, subtotal, total } = req.body;
    
    // Associate quote with current user if no patient ID provided
    const patientId = patientInfo.id || req.user.id;
    
    const quote = await req.storage.createQuote({
      patientId,
      patientInfo,
      treatments,
      promoCode,
      discountPercent,
      subtotal,
      total,
      createdBy: req.user.id,
      createdAt: new Date()
    });
    
    res.status(201).json({ quote });
  } catch (error) {
    console.error('Error creating quote:', error);
    res.status(500).json({ error: 'Failed to create quote' });
  }
});

// Update an existing quote
router.put('/:quoteId', authenticateUser, async (req, res) => {
  try {
    const { quoteId } = req.params;
    const existingQuote = await req.storage.getQuoteById(quoteId);
    
    if (!existingQuote) {
      return res.status(404).json({ error: 'Quote not found' });
    }
    
    // Ensure users can only update their own quotes or clinic staff can update their clinic's quotes
    if (
      req.user.id !== existingQuote.patientId && 
      req.user.clinicId !== existingQuote.clinicId && 
      !req.user.roles.includes('admin')
    ) {
      return res.status(403).json({ error: 'Unauthorized access' });
    }
    
    const { patientInfo, treatments, promoCode, discountPercent, subtotal, total } = req.body;
    
    const updatedQuote = await req.storage.updateQuote(quoteId, {
      patientInfo,
      treatments,
      promoCode,
      discountPercent,
      subtotal,
      total,
      updatedBy: req.user.id,
      updatedAt: new Date()
    });
    
    res.json({ quote: updatedQuote });
  } catch (error) {
    console.error('Error updating quote:', error);
    res.status(500).json({ error: 'Failed to update quote' });
  }
});

export default router;
Update Storage Implementation
// server/storage.ts
// Add these methods to the DatabaseStorage class

async getQuotesByPatientId(patientId: string): Promise<Quote[]> {
  try {
    const quotes = await this.db.collection('quotes')
      .find({ patientId })
      .sort({ createdAt: -1 })
      .toArray();
    
    return quotes;
  } catch (error) {
    console.error('Error fetching quotes by patient ID:', error);
    throw error;
  }
}

async getQuotesByClinicId(clinicId: string): Promise<Quote[]> {
  try {
    const quotes = await this.db.collection('quotes')
      .find({ clinicId })
      .sort({ createdAt: -1 })
      .toArray();
    
    return quotes;
  } catch (error) {
    console.error('Error fetching quotes by clinic ID:', error);
    throw error;
  }
}

async getQuoteById(quoteId: string): Promise<Quote | null> {
  try {
    const quote = await this.db.collection('quotes').findOne({ _id: quoteId });
    return quote;
  } catch (error) {
    console.error('Error fetching quote by ID:', error);
    throw error;
  }
}

async createQuote(quoteData: QuoteData): Promise<Quote> {
  try {
    const result = await this.db.collection('quotes').insertOne({
      ...quoteData,
      _id: generateId(), // Implement a function to generate unique IDs
      createdAt: new Date()
    });
    
    return await this.getQuoteById(result.insertedId);
  } catch (error) {
    console.error('Error creating quote:', error);
    throw error;
  }
}

async updateQuote(quoteId: string, quoteData: Partial<QuoteData>): Promise<Quote | null> {
  try {
    await this.db.collection('quotes').updateOne(
      { _id: quoteId },
      { 
        $set: {
          ...quoteData,
          updatedAt: new Date()
        }
      }
    );
    
    return await this.getQuoteById(quoteId);
  } catch (error) {
    console.error('Error updating quote:', error);
    throw error;
  }
}
4. Authentication Integration
We need to update the quote store to include authentication details:

// client/src/stores/quoteStore.ts
// Updated applyPromoCode and saveQuote functions to include auth tokens

applyPromoCode: async (code) => {
  console.log('[QuoteStore] Applying promo code:', code);
  
  set(state => ({ 
    loading: { ...state.loading, promoCode: true } 
  }));
  
  try {
    // Get auth token
    const token = localStorage.getItem('auth_token');
    
    // Try the API endpoint
    const response = await fetch('/api/quotes/promo-codes/validate', {
      method: 'POST',
      headers: { 
        'Content-Type': 'application/json',
        'Authorization': token ? `Bearer ${token}` : ''
      },
      body: JSON.stringify({ code })
    });
    
    // Rest of the function remains the same...
  } catch (error) {
    // Error handling remains the same...
  }
},

saveQuote: async () => {
  console.log('[QuoteStore] Saving quote');
  
  const state = get();
  set({ loading: { ...state.loading, saving: true } });
  
  try {
    // Get auth token
    const token = localStorage.getItem('auth_token');
    
    const response = await fetch('/api/quotes', {
      method: 'POST',
      headers: { 
        'Content-Type': 'application/json',
        'Authorization': token ? `Bearer ${token}` : ''
      },
      body: JSON.stringify({
        patientInfo: state.patientInfo,
        treatments: state.treatments,
        promoCode: state.promoCode,
        discountPercent: state.discountPercent,
        subtotal: state.subtotal,
        total: state.total
      })
    });
    
    // Rest of the function remains the same...
  } catch (error) {
    // Error handling remains the same...
  }
}
5. Create Quote Detail Page
// client/src/pages/QuoteDetailPage.tsx
import { useState, useEffect } from 'react';
import { useParams, Link } from 'react-router-dom';
import { formatDate } from '../utils/date-formatter';
import { formatCurrency } from '../utils/currency-formatter';

export function QuoteDetailPage() {
  const { quoteId } = useParams();
  const [quote, setQuote] = useState(null);
  const [loading, setLoading] = useState(true);
  const [error, setError] = useState(null);
  
  useEffect(() => {
    async function fetchQuote() {
      try {
        setLoading(true);
        
        // Get auth token
        const token = localStorage.getItem('auth_token');
        
        const response = await fetch(`/api/quotes/${quoteId}`, {
          headers: {
            'Authorization': token ? `Bearer ${token}` : ''
          }
        });
        
        if (!response.ok) {
          throw new Error('Failed to fetch quote details');
        }
        
        const data = await response.json();
        setQuote(data.quote);
      } catch (err) {
        console.error('Error fetching quote details:', err);
        setError('Unable to load quote details. Please try again later.');
      } finally {
        setLoading(false);
      }
    }
    
    fetchQuote();
  }, [quoteId]);
  
  if (loading) {
    return <div className="loading">Loading quote details...</div>;
  }
  
  if (error) {
    return <div className="error-message">{error}</div>;
  }
  
  if (!quote) {
    return <div className="not-found">Quote not found</div>;
  }
  
  return (
    <div className="quote-detail-page">
      <header className="page-header">
        <h1>Quote #{quote.id}</h1>
        <div className="quote-meta">
          <span>Created: {formatDate(quote.createdAt)}</span>
          {quote.updatedAt && <span>Updated: {formatDate(quote.updatedAt)}</span>}
        </div>
      </header>
      
      <section className="patient-info">
        <h2>Patient Information</h2>
        <div className="info-grid">
          <div className="info-item">
            <label>Name:</label>
            <span>{quote.patientInfo.name}</span>
          </div>
          <div className="info-item">
            <label>Email:</label>
            <span>{quote.patientInfo.email}</span>
          </div>
          <div className="info-item">
            <label>Phone:</label>
            <span>{quote.patientInfo.phone}</span>
          </div>
          {/* Add more patient info fields as needed */}
        </div>
      </section>
      
      <section className="treatments-section">
        <h2>Selected Treatments</h2>
        <table className="treatments-table">
          <thead>
            <tr>
              <th>Treatment</th>
              <th>Price</th>
              <th>Quantity</th>
              <th>Total</th>
            </tr>
          </thead>
          <tbody>
            {quote.treatments.map(treatment => (
              <tr key={treatment.id}>
                <td>{treatment.name}</td>
                <td>{formatCurrency(treatment.price)}</td>
                <td>{treatment.quantity}</td>
                <td>{formatCurrency(treatment.price * treatment.quantity)}</td>
              </tr>
            ))}
          </tbody>
        </table>
      </section>
      
      <section className="quote-summary">
        <div className="summary-row">
          <span>Subtotal:</span>
          <span>{formatCurrency(quote.subtotal)}</span>
        </div>
        
        {quote.promoCode && (
          <div className="summary-row discount">
            <span>Discount ({quote.discountPercent}% - {quote.promoCode}):</span>
            <span>-{formatCurrency(quote.subtotal - quote.total)}</span>
          </div>
        )}
        
        <div className="summary-row total">
          <span>Total:</span>
          <span>{formatCurrency(quote.total)}</span>
        </div>
      </section>
      
      <div className="action-buttons">
        <Button as={Link} to={`/quotes/${quote.id}/print`} variant="primary">
          Print Quote
        </Button>
        <Button as={Link} to="/quote" state={{ fromQuoteId: quote.id }} variant="outline">
          Create Similar Quote
        </Button>
        <Button as={Link} to={`/book-appointment?quoteId=${quote.id}`} variant="accent">
          Book Appointment
        </Button>
      </div>
    </div>
  );
}
6. Add Routes to App.tsx
// client/src/App.tsx
import { QuoteDetailPage } from './pages/QuoteDetailPage';
import { QuotePrintPage } from './pages/QuotePrintPage';

// In your Routes component
<Routes>
  {/* Existing routes */}
  <Route path="/quote" element={<EnhancedQuotePage />} />
  <Route path="/quotes/:quoteId" element={<QuoteDetailPage />} />
  <Route path="/quotes/:quoteId/print" element={<QuotePrintPage />} />
</Routes>
7. Email Integration
Add email notification for new quotes:

// server/routes/quotes.ts
// In the POST route for creating a new quote

// Save a new quote
router.post('/', authenticateUser, async (req, res) => {
  try {
    // Existing code...
    
    const quote = await req.storage.createQuote({
      // Quote data...
    });
    
    // Send email notification
    if (patientInfo.email) {
      await sendQuoteEmail({
        to: patientInfo.email,
        quoteId: quote._id,
        patientName: patientInfo.name,
        total: total,
        treatmentCount: treatments.length
      });
    }
    
    res.status(201).json({ quote });
  } catch (error) {
    // Error handling...
  }
});

// Helper function to send email
async function sendQuoteEmail({ to, quoteId, patientName, total, treatmentCount }) {
  try {
    // Using your email service (e.g., SendGrid, Mailjet, etc.)
    await emailService.send({
      to,
      subject: 'Your Dental Treatment Quote',
      template: 'quote-confirmation',
      data: {
        patientName,
        quoteId,
        total: formatCurrency(total),
        treatmentCount,
        quoteUrl: `${process.env.WEBSITE_URL}/quotes/${quoteId}`,
        expiryDate: new Date(Date.now() + 30 * 24 * 60 * 60 * 1000) // 30 days from now
      }
    });
    
    console.log(`Quote email sent to ${to} for quote ${quoteId}`);
  } catch (error) {
    console.error('Error sending quote email:', error);
    // Don't throw - we don't want to fail the quote creation if email fails
  }
}
8. Testing Plan for Portal Integration
Website Navigation Testing:

Verify quote builder is accessible from main navigation
Test homepage CTA button leads to quote builder
Ensure "Add to Quote" buttons on treatment pages work correctly
Patient Portal Testing:

Verify quotes list appears in patient portal
Test quote creation from patient portal
Ensure quote details page shows correct information
Verify print functionality works from portal
Clinic Portal Testing:

Verify clinic staff can see quotes for their clinic
Test filtering and sorting of quotes
Ensure quote details match what patient sees
Verify appointment booking from quotes works correctly
Authentication Testing:

Verify unauthenticated users can create quotes but are prompted to sign in to save
Test that authenticated users' quotes are automatically associated with their account
Ensure users can only access their own quotes
Verify clinic staff can only access quotes for their clinic
Email Integration Testing:

Verify confirmation emails are sent when quotes are created
Test email templates render correctly
Ensure links in emails work properly
9. Implementation Checklist
 Website Integration

 Add quote builder to main navigation
 Create homepage CTA for quote builder
 Add "Add to Quote" buttons on treatment pages
 Portal Integration

 Create QuotesList component for portals
 Add quotes section to patient portal
 Add quotes section to clinic portal
 Create QuoteDetailPage component
 Create QuotePrintPage component
 Server-Side Integration

 Create API endpoints for quote management
 Implement storage methods for quotes
 Add authentication middleware to quote routes
 Implement email notifications for quotes
 Authentication Integration

 Update quote store to include auth tokens
 Add logic to associate quotes with authenticated users
 Implement access control for quote data
 Testing

 Test website navigation to quote builder
 Test quote creation and saving
 Test quote retrieval in portals
 Test authentication integration
 Test email notifications
By following this implementation plan, you'll have a fully integrated quote system that connects seamlessly with your patient and clinic portals, ensuring quotes are properly populated and accessible to the right users without breaking any existing functionality.