# Promo & Treatment‑Package Integration – Technical Brief

## 0. Project Context

You are working on **MyDentalFly**, a multi‑portal dental‑tourism platform (patient, clinic, admin) built in a Replit TS/React/Express stack.  The core quote flow already works (city & date search → dental quiz & chart → price guidance → clinic results → portal sign‑up).  **Missing piece:** first‑class, scalable support for **Special Offers** and **Treatment Packages** ("Promos").

## 1. Objective

Embed special offers/packages so that:

* A promo selected on the homepage persists through **every** step – quote builder, results, portals.
* Pricing, validations, and bundled extras are applied automatically.
* Only the clinic(s) participating in the promo are highlighted; others show normal pricing.
* Attribution (UTM/email tokens) is tracked end‑to‑end.
* The solution scales to new treatments, cities, and countries with minimal code changes.

## 2. Core Concept

> A promo is a **bundle** (treatments ＋ extras) **＋** a discount rule **＋** tracking metadata.  A user journey carries at most one active promo (or "NONE").

## 3. Data‑Model Additions (PostgreSQL via **Prisma**)

```
model Promo              { id String @id @default(uuid())
                            slug           String  @unique
                            title          String
                            description    String
                            promoType      PromoType
                            discountType   DiscountType
                            discountValue  Float
                            heroImageUrl   String?
                            startDate      DateTime
                            endDate        DateTime
                            isActive       Boolean @default(true)
                            cityCode       String?  // scaling
                            countryCode    String?
                            validationSchema Json?  // JSONB rules
                            promoItems     PromoItem[]
                            promoClinics   PromoClinic[]
                            promoTokens    PromoToken[]
                          }

model PromoItem          { id String @id @default(uuid())
                            promoId   String
                            itemType  ItemType
                            itemCode  String
                            qty       Int
                            promo     Promo @relation(fields:[promoId], references:[id]) }

model PromoClinic        { id String @id @default(uuid())
                            promoId  String
                            clinicId String
                            promo    Promo  @relation(fields:[promoId], references:[id]) }

model PromoToken         { id String @id @default(uuid())
                            promoId  String
                            token    String  @unique
                            source   TokenSource
                            userId   String?
                            createdAt DateTime @default(now())
                            promo     Promo   @relation(fields:[promoId], references:[id]) }

// Add `promoId` FK to Quote.
```

*Enums*: `PromoType { OFFER, PACKAGE }`, `DiscountType { PERCENT, FIXED }`, `ItemType { TREATMENT, EXTRA }`, `TokenSource { WEB, EMAIL, UTM }`.

## 4. API Contract (Express / **tRPC**)

| Route                | Method | Purpose                                                  |
| -------------------- | ------ | -------------------------------------------------------- |
| `/promo/validate`    | POST   | Check if promo is valid for clinic & selected treatments |
| `/quotes/from-promo` | POST   | Create quote + auto‑apply bundle & discount              |
| `/quotes/:id`        | GET    | Return quote incl. promo payload                         |

## 5. Front‑End State Flow (React + React‑Query + Zustand)

```mermaid
graph TD
A[Home ➜ PromoCard click] -->|store promo| Z[GlobalStore]
Z --> Q[QuoteBuilder]
Q --> R[ResultsPage]
R --> P[PatientPortal]
```

*Promo slug also travels in URL for share‑links.*

## 6. Conflict & Upsell Logic

*Validate both client‑side and server‑side against `validationSchema`.*

```ts
if (promo.slug === "ALLIN6" && extraImplants.length) {
  warn("Package already includes 6 implants; extras billed separately.");
}
```

## 7. Tracking & Analytics

* On landing, parse `?promo=` or `/p/:token`, insert **PromoToken**, store `tokenId` in `sessionStorage`.
* Attach `promoTokenId` when creating quote.
* Emit Mixpanel `PromoApplied` + revenue attribution.

## 8. Libraries / Packages

| Concern            | Library                       |
| ------------------ | ----------------------------- |
| ORM & migrations   | **Prisma**                    |
| Server transport   | **tRPC** over Express         |
| Forms & validation | **React‑Hook‑Form** + **Zod** |
| Global state       | **Zustand**                   |
| Auth / RBAC        | **Clerk** or **NextAuth.js**  |
| CMS for promo copy | **Strapi** (optional)         |
| Analytics          | **Mixpanel** or **PostHog**   |

## 9. Scaling Strategy

1. Add `cityCode` / `countryCode` on **Promo** & **Clinic** ⇒ filter by search city.
2. Store feature flags in `features` table for reversible roll‑outs.
3. Extract discount logic into a separate microservice once multiple verticals (e.g., cosmetic surgery) are live.

## 10. Step‑by‑Step for Replit AI‑Agent

1. **Branch** `feat/promo-engine`.
2. **Add Prisma models** (§3) → run migrations.
3. **Seed** DB with two sample promos & link to demo clinic.
4. **Expose** routes (§4) via tRPC.
5. **Refactor QuoteBuilder**: show promo ribbon, apply discounts & warnings.
6. **Modify ResultsPage**: pin promo clinic, badge others.
7. **Extend PatientPortal** TreatmentPlan tab to display promo summary.
8. **Implement tracking** middleware writing `promo_tokens`.
9. **Write Jest tests** for discount & validation.
10. **QA**: mobile, currency conversion, multi‑city filter, expired promo edge cases.

## 11. TL;DR

> *“Build a promo engine:”*  New Prisma tables, single‑promo state, discount & validation at quote creation, results pinned, portals show promo, token tracking, Mixpanel events, city‑aware queries, feature‑flagged rollout.
