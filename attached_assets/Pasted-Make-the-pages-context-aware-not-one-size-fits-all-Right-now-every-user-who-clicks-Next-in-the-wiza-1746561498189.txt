Make the pages context‑aware, not one‑size‑fits‑all
Right now every user who clicks Next in the wizard is routed to the same next page, even when

we already know which clinic they want (Special Offer / Package), or

we already have their personal info in the session.

That’s why the journey feels repetitive.
Instead of duplicating whole pages, give the same page component a tiny bit of context so it can skip or reshape itself.

1  Carry the “entry source” through the whole session
After the very first click, attach one flag to the quote object (or to React Context):

Source	Flag on quote
Header‑quote	source="normal"
Special Offer card	source="special_offer", offerId=xyz
Package card	source="package", packageId=abc

That single field lets every later page decide what to show or hide.

2  Wizard step logic (pseudo‑code)
ts
Copy
Edit
function WizardRouter({ quote }: { quote: Quote }) {
  switch (step) {
    case 'Info':
      // Skip if we already have name+phone and user came from offer/package
      if (quote.source !== 'normal' && hasProfileData(user)) {
        return <Navigate to="TreatmentMap" />;
      }
      return <InfoStep />;

    case 'Results':
      // Skip results for offer/package
      if (quote.source !== 'normal') {
        return <Navigate to={`/portal/quote/${quote.id}/review`} />;
      }
      return <ResultsStep />;
  }
}
3  Component tweaks instead of new pages
Page	Normal behaviour	When source="special_offer" or "package"
Treatment Review	User can remove any line	• Bonus / package lines are greyed & locked
• Big banner: “🎁 Free Return Flights included”
Portal Dashboard	“Finish your quote” CTA	• Toast: “Your package is ready—upload X‑rays to confirm”
Quote Summary email	Generic header	• Subject line includes offer title (“Free Flights quote #45”)

4  Routing changes needed (tiny)
Route	Before	After
/wizard/results	Always rendered	Render only if quote.source === "normal"
/portal/quote/:id/review	Reached after results	Reached directly for offer/package

All other pages stay the same; they just read that quote.source flag.

5  How to implement quickly in Replit
Add source column to quotes (enum: normal | special_offer | package).

In the POST endpoints that create a quote from an offer/package, populate that column.

Add a little helper in front‑end context:

ts
Copy
Edit
export function useQuote() {
  const quote = useContext(QuoteContext);
  const isOffer = quote?.source === 'special_offer';
  const isPackage = quote?.source === 'package';
  return { quote, isOffer, isPackage };
}
Gate each step with one‑liners:

tsx
Copy
Edit
const { isOffer } = useQuote();
if (isOffer && hasProfileData) return <Navigate to="Review" />;
Keep one wizard file—no forks, no page duplication, just early returns.

Why this beats creating new pages
Less code → fewer bugs, easier styling.

Keeps URL structure identical, so SEO, analytics, and deep‑links don’t multiply.

You can add future sources (e.g. “clinic_widget”) by inserting one new enum value and two guard lines—no redesign.

Adopt this “context‑aware page” pattern and the user experience will feel tailored without a maze of nearly‑identical components. Let me know if you’d like code snippets for a specific step, or an update to the architecture diagram to reflect the new flags!







