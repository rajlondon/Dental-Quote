Hereâ€™s a fast-track checklist that usually stops the â€œlog-in succeeds â†’ portal keeps refreshing / blank-loopsâ€ problem in React Router apps. Work through it in order; most teams find the culprit by step 4.

1. Confirm one source of truth for â€œlogged-in clinic userâ€

Where you store it	What to check
localStorage / cookie	â€“ After the clinic user logs in, open DevTools â†’ Application â†’ Local Storage. Did the token / â€œclinicAuthâ€ flag actually appear?
â€“ Is it spelled the same everywhere ("clinicToken" vs "clinic_token")?
React context / Redux	â€“ If you rely on context alone, it is cleared on a full page refresh. Any <a> tag or window.location.href navigation will wipe it and youâ€™ll loop back to /login.
â€“ Fix: write the token (or a â€œloggedIn=trueâ€ flag) to localStorage once on login, then read it in AuthProviderâ€™s useEffect at startup.
2. Protect the route with a loading state
A common infinite-redirect looks like this:

jsx
Copy
Edit
// ğŸš¨ causes redirect loop
if (!isLoggedIn) navigate("/clinic/login");
When the app boots, isLoggedIn is undefined for a few milliseconds, so the guard misfires.
Use an explicit loading flag:

jsx
Copy
Edit
const { isLoggedIn, loading } = useAuth();   // loading true until weâ€™ve read LS / verified token
if (loading) return null;                    // or a spinner
if (!isLoggedIn) return <Navigate to="/clinic/login" replace />;
return children;
3. Make sure only one place redirects after login
Your handleLogin does navigate("/clinic").

useEffect in ClinicDashboard also calls navigate("/clinic") when it sees a fresh token.

Together they bounce the user forever. Pick one:

jsx
Copy
Edit
// LoginForm.jsx
await login();
navigate("/clinic");        // âœ… remove all other auto-redirects
4. Verify the router basename & server fallback
If the page loads once, then the browser refreshes and you get a 404 â†’ blank page â†’ redirect loop:

tsx
Copy
Edit
<BrowserRouter basename="/clinic">   // OR HashRouter if you canâ€™t change server
and on the server (Express / Replit webview):

js
Copy
Edit
app.get('*', (_req, res) => {
  res.sendFile(path.join(__dirname, 'dist', 'index.html'));
});
Without that wildcard, any hard refresh at /clinic/dashboard asks the server for an actual file called â€œclinic/dashboardâ€, gets a 404, and React never mounts.

5. Watch for repeated state changes inside <ProtectedRoute>
Every time you set state inside a component that immediately renders again, you trigger another state change â†’ render â†’ state changeâ€¦ Example:

jsx
Copy
Edit
useEffect(() => {
  if (!userRoleFetched) {
    fetchRole().then(setRole);   // âœ… OK
  } else if (role !== "clinic") {
    navigate("/403");            // âœ… OK
  }
}, [userRoleFetched, role]);      // ğŸš« DONâ€™T add â€œnavigateâ€ or â€œlocationâ€ to deps
Adding navigate or location to the dependency array re-runs the effect after every redirect.

6. Tools that help in Replit

Tool	Why it helps
Network tab	See if the app is hammering /clinic, /, then /clinic again. If you see that ping-pong, a redirect loop is certain.
â€œLog pointâ€ in DevTools	Right-click at the top of AuthProvider â†’ Add logpoint â†’ console.log("isLoggedIn", isLoggedIn). Youâ€™ll watch it flip false â†’ true â†’ false â†’ true in a fraction of a second.
Replit Secrets panel	Double-check the .env values that your auth API uses are identical in the deployed fork. A wrong URL or API key often returns 401 â†’ redirect loop.
Quick experiment: isolate the clinic route
Temporarily comment out all redirects and return the JSON of your auth state in the dashboard:

jsx
Copy
Edit
return <pre>{JSON.stringify({ isLoggedIn, user }, null, 2)}</pre>;
If the loop stops, your redirect guard is the offender. If it still loops, the login request itself is failing (network 401/403).

Still stuck?
Share:

The component that stores the token on login

Your <Routes> block for /clinic/*

The ProtectedRoute (or equivalent) wrapper

