Here’s a fast-track checklist that usually stops the “log-in succeeds → portal keeps refreshing / blank-loops” problem in React Router apps. Work through it in order; most teams find the culprit by step 4.

1. Confirm one source of truth for “logged-in clinic user”

Where you store it	What to check
localStorage / cookie	– After the clinic user logs in, open DevTools → Application → Local Storage. Did the token / “clinicAuth” flag actually appear?
– Is it spelled the same everywhere ("clinicToken" vs "clinic_token")?
React context / Redux	– If you rely on context alone, it is cleared on a full page refresh. Any <a> tag or window.location.href navigation will wipe it and you’ll loop back to /login.
– Fix: write the token (or a “loggedIn=true” flag) to localStorage once on login, then read it in AuthProvider’s useEffect at startup.
2. Protect the route with a loading state
A common infinite-redirect looks like this:

jsx
Copy
Edit
// 🚨 causes redirect loop
if (!isLoggedIn) navigate("/clinic/login");
When the app boots, isLoggedIn is undefined for a few milliseconds, so the guard misfires.
Use an explicit loading flag:

jsx
Copy
Edit
const { isLoggedIn, loading } = useAuth();   // loading true until we’ve read LS / verified token
if (loading) return null;                    // or a spinner
if (!isLoggedIn) return <Navigate to="/clinic/login" replace />;
return children;
3. Make sure only one place redirects after login
Your handleLogin does navigate("/clinic").

useEffect in ClinicDashboard also calls navigate("/clinic") when it sees a fresh token.

Together they bounce the user forever. Pick one:

jsx
Copy
Edit
// LoginForm.jsx
await login();
navigate("/clinic");        // ✅ remove all other auto-redirects
4. Verify the router basename & server fallback
If the page loads once, then the browser refreshes and you get a 404 → blank page → redirect loop:

tsx
Copy
Edit
<BrowserRouter basename="/clinic">   // OR HashRouter if you can’t change server
and on the server (Express / Replit webview):

js
Copy
Edit
app.get('*', (_req, res) => {
  res.sendFile(path.join(__dirname, 'dist', 'index.html'));
});
Without that wildcard, any hard refresh at /clinic/dashboard asks the server for an actual file called “clinic/dashboard”, gets a 404, and React never mounts.

5. Watch for repeated state changes inside <ProtectedRoute>
Every time you set state inside a component that immediately renders again, you trigger another state change → render → state change… Example:

jsx
Copy
Edit
useEffect(() => {
  if (!userRoleFetched) {
    fetchRole().then(setRole);   // ✅ OK
  } else if (role !== "clinic") {
    navigate("/403");            // ✅ OK
  }
}, [userRoleFetched, role]);      // 🚫 DON’T add “navigate” or “location” to deps
Adding navigate or location to the dependency array re-runs the effect after every redirect.

6. Tools that help in Replit

Tool	Why it helps
Network tab	See if the app is hammering /clinic, /, then /clinic again. If you see that ping-pong, a redirect loop is certain.
“Log point” in DevTools	Right-click at the top of AuthProvider → Add logpoint → console.log("isLoggedIn", isLoggedIn). You’ll watch it flip false → true → false → true in a fraction of a second.
Replit Secrets panel	Double-check the .env values that your auth API uses are identical in the deployed fork. A wrong URL or API key often returns 401 → redirect loop.
Quick experiment: isolate the clinic route
Temporarily comment out all redirects and return the JSON of your auth state in the dashboard:

jsx
Copy
Edit
return <pre>{JSON.stringify({ isLoggedIn, user }, null, 2)}</pre>;
If the loop stops, your redirect guard is the offender. If it still loops, the login request itself is failing (network 401/403).

Still stuck?
Share:

The component that stores the token on login

Your <Routes> block for /clinic/*

The ProtectedRoute (or equivalent) wrapper

