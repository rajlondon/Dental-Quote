Looking at the files created, I don't see explicit components for:

Special Offers Data Model: There's no clear indication of a data structure specifically for special offers and treatment packages in the schema.ts file.

Offer Application Logic: No visible components for calculating discounted prices or applying package pricing.

Offer Selection UI: No dedicated components for highlighting and selecting special offers throughout the quote flow.

Pricing Adjustments: No clear mechanism for adjusting prices based on selected offers in the treatment summary.

Implementation Suggestions
To properly implement special offers on top of Replit's foundation, we should:

1. Extend the Schema
// Add to shared/schema.ts
export interface SpecialOffer {
  id: string;
  name: string;
  description: string;
  discountType: 'percentage' | 'fixed' | 'package';
  discountValue: number;
  applicableTreatmentIds: string[];
  validFrom: string;
  validTo: string;
  clinicIds: string[];
  highlighted: boolean;
}

export interface TreatmentPackage {
  id: string;
  name: string;
  description: string;
  includedTreatments: {
    treatmentId: string;
    quantity: number;
  }[];
  packagePrice: number;
  regularPrice: number;
  clinicIds: string[];
  highlighted: boolean;
}

// Update the existing TreatmentPlan interface to include offers
export interface TreatmentPlan {
  // existing properties
  appliedOffers: {
    treatmentId: string;
    offerId: string;
  }[];
  appliedPackages: string[]; // package IDs
}
2. Create Special Offers Provider
// client/src/components/SpecialOffersProvider.tsx
import React, { createContext, useContext, useState, useEffect } from 'react';
import { SpecialOffer, TreatmentPackage } from '../../../shared/schema';
import { fetchOffers, fetchPackages } from '../api/offers-api';

interface SpecialOffersContextType {
  offers: SpecialOffer[];
  packages: TreatmentPackage[];
  loading: boolean;
  applyOfferToTreatment: (treatmentId: string, offerId: string) => number;
  getApplicableOffers: (treatmentId: string, clinicId: string) => SpecialOffer[];
  getHighlightedOffers: () => SpecialOffer[];
  // other methods
}

const SpecialOffersContext = createContext<SpecialOffersContextType | null>(null);

export const SpecialOffersProvider: React.FC = ({ children }) => {
  const [offers, setOffers] = useState<SpecialOffer[]>([]);
  const [packages, setPackages] = useState<TreatmentPackage[]>([]);
  const [loading, setLoading] = useState(true);
  
  useEffect(() => {
    const loadData = async () => {
      try {
        const [offersData, packagesData] = await Promise.all([
          fetchOffers(),
          fetchPackages()
        ]);
        setOffers(offersData);
        setPackages(packagesData);
      } catch (error) {
        console.error('Failed to load offers:', error);
      } finally {
        setLoading(false);
      }
    };
    
    loadData();
  }, []);

  // Implementation of context methods
  const applyOfferToTreatment = (treatmentId: string, offerId: string) => {
    // Price calculation logic
    // ...
  };
  
  // Other methods
  
  return (
    <SpecialOffersContext.Provider value={{
      offers,
      packages,
      loading,
      applyOfferToTreatment,
      getApplicableOffers,
      getHighlightedOffers,
      // other methods
    }}>
      {children}
    </SpecialOffersContext.Provider>
  );
};

export const useSpecialOffers = () => {
  const context = useContext(SpecialOffersContext);
  if (!context) {
    throw new Error('useSpecialOffers must be used within a SpecialOffersProvider');
  }
  return context;
};
3. Integrate with Treatment Plan Builder
// Modify client/src/components/TreatmentPlanBuilder.tsx
import { useSpecialOffers } from '../hooks/use-special-offers';
import { useUnifiedTreatmentPlans } from '../hooks/use-unified-treatment-plans';

const TreatmentPlanBuilder = () => {
  const { currentPlan, updatePlan } = useUnifiedTreatmentPlans();
  const { getApplicableOffers, applyOfferToTreatment } = useSpecialOffers();
  
  // When rendering a treatment item
  const renderTreatmentItem = (treatment) => {
    const applicableOffers = getApplicableOffers(treatment.id, currentPlan.clinicId);
    
    return (
      <div className="treatment-item">
        <div className="treatment-details">
          <h4>{treatment.name}</h4>
          <p>£{treatment.price}</p>
        </div>
        
        {applicableOffers.length > 0 && (
          <div className="offers-section">
            <label>Available Offers:</label>
            <select 
              onChange={(e) => handleOfferSelection(treatment.id, e.target.value)}
              value={getAppliedOfferId(treatment.id)}
            >
              <option value="">No offer</option>
              {applicableOffers.map(offer => (
                <option key={offer.id} value={offer.id}>
                  {offer.name} - Save {formatDiscount(offer)}
                </option>
              ))}
            </select>
          </div>
        )}
      </div>
    );
  };
  
  const handleOfferSelection = (treatmentId, offerId) => {
    // Update the treatment plan with the selected offer
    const updatedAppliedOffers = [...currentPlan.appliedOffers.filter(
      ao => ao.treatmentId !== treatmentId
    )];
    
    if (offerId) {
      updatedAppliedOffers.push({ treatmentId, offerId });
    }
    
    updatePlan({
      ...currentPlan,
      appliedOffers: updatedAppliedOffers
    });
  };
  
  // Rest of component
};
4. Update Plan Summary View
// Modify client/src/components/PlanSummaryView.tsx
import { useSpecialOffers } from '../hooks/use-special-offers';

const PlanSummaryView = ({ plan }) => {
  const { applyOfferToTreatment } = useSpecialOffers();
  
  const calculateTreatmentPrice = (treatment) => {
    const appliedOffer = plan.appliedOffers.find(
      ao => ao.treatmentId === treatment.id
    );
    
    if (appliedOffer) {
      return applyOfferToTreatment(treatment.id, appliedOffer.offerId);
    }
    
    return treatment.price;
  };
  
  const renderTreatmentLineItem = (treatment) => {
    const originalPrice = treatment.price;
    const finalPrice = calculateTreatmentPrice(treatment);
    const hasDiscount = originalPrice !== finalPrice;
    
    return (
      <div className="line-item">
        <span>{treatment.name}</span>
        {hasDiscount ? (
          <div className="discounted-price">
            <span className="original-price">£{originalPrice}</span>
            <span className="final-price">£{finalPrice}</span>
          </div>
        ) : (
          <span>£{originalPrice}</span>
        )}
      </div>
    );
  };
  
  // Rest of component
};
5. Backend API Extensions
// Add to server/controllers/treatment-plans.ts
export const getSpecialOffers = async (req, res) => {
  try {
    const { clinicId } = req.query;
    // Fetch offers from database with filters
    const offers = await db.specialOffers.findAll({
      where: {
        clinicIds: { $contains: [clinicId] },
        validFrom: { $lte: new Date() },
        validTo: { $gte: new Date() }
      }
    });
    
    res.json(offers);
  } catch (error) {
    res.status(500).json({ error: 'Failed to fetch special offers' });
  }
};

// Add to server/routes/treatment-routes.ts
router.get('/special-offers', getSpecialOffers);
router.get('/treatment-packages', getTreatmentPackages);
Conclusion
The Replit agent has created a solid foundation with the unified treatment plans system, but it appears to be missing the specific features needed for special offers and treatment packages. By extending their implementation with the components I've outlined above, you should be able to:

Define and manage special offers and packages
Apply them to treatments in the quote flow
Show discounted prices in the treatment summary
Highlight special offers throughout the user journey