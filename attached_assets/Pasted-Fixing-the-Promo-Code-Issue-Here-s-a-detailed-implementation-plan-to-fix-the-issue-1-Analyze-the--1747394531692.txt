Fixing the Promo Code Issue
Here's a detailed implementation plan to fix the issue:

1. Analyze the Current Implementation
First, we need to understand exactly where the state is being reset. Let's examine the use-quote-builder.ts hook and identify the problematic code.

2. Implement a Robust State Management Solution
// Modified implementation for applyPromoCode in use-quote-builder.ts

const applyPromoCode = async (code: string) => {
  setIsLoading(true);
  
  try {
    // Store the current treatments before making the API call
    const currentTreatments = [...quote.treatments];
    
    const response = await validatePromoCode(code);
    
    // Use functional update to ensure we have the latest state
    setQuote(prevQuote => {
      // Calculate the discount based on the promo code
      const subtotal = calculateSubtotal(prevQuote.treatments);
      let promoDiscount = 0;
      
      if (response.discountType === 'percentage') {
        promoDiscount = (subtotal * response.discountValue / 100);
      } else if (response.discountType === 'fixed') {
        promoDiscount = response.discountValue;
      }
      
      // Ensure discount doesn't exceed subtotal
      promoDiscount = Math.min(promoDiscount, subtotal);
      
      // Return a new quote object that PRESERVES the treatments array
      return {
        ...prevQuote,
        treatments: currentTreatments, // Keep the existing treatments!
        promoCode: code,
        promoDiscount: promoDiscount,
        subtotal: subtotal,
        total: subtotal - promoDiscount
      };
    });
    
    // Add logging to verify the state after update
    console.log("[QuoteBuilder] Updated quote after promo code application:", quote);
    
    toast.success("Promo code applied successfully!");
  } catch (error) {
    console.error("[QuoteBuilder] Error applying promo code:", error);
    toast.error("Invalid promo code");
  } finally {
    setIsLoading(false);
  }
};
3. Ensure Proper Initialization
We should also ensure the quote state is properly initialized with an empty treatments array:

// In use-quote-builder.ts

const [quote, setQuote] = useState<Quote>({
  id: '',
  treatments: [], // Initialize with empty array
  subtotal: 0,
  promoCode: null,
  promoDiscount: 0,
  total: 0,
  patientName: '',
  patientEmail: '',
  createdAt: new Date().toISOString()
});
4. Add Defensive Programming
Add checks to ensure we don't try to operate on undefined values:

const calculateSubtotal = (treatments: Treatment[] = []) => {
  if (!treatments || !Array.isArray(treatments)) {
    console.warn("[QuoteBuilder] Treatments is not an array:", treatments);
    return 0;
  }
  
  return treatments.reduce((sum, treatment) => sum + treatment.price, 0);
};
5. Implement a Debugging Component
For testing purposes, add a small debugging component to the quote builder:

// In QuoteBuilder.tsx

const DebugSection = () => {
  if (process.env.NODE_ENV !== 'development') return null;
  
  return (
    <div className="mt-4 p-4 border border-gray-200 rounded bg-gray-50">
      <h3 className="text-sm font-medium">Debug Info</h3>
      <div className="mt-2 text-xs font-mono">
        <div>Selected treatments: {quote.treatments?.length || 0}</div>
        <div>Subtotal: ${quote.subtotal.toFixed(2)}</div>
        <div>Promo code: {quote.promoCode || 'None'}</div>
        <div>Discount: ${quote.promoDiscount.toFixed(2)}</div>
        <div>Total: ${quote.total.toFixed(2)}</div>
      </div>
    </div>
  );
};

// Add this component at the bottom of the QuoteBuilder render function
6. Ensure Proper Re-rendering
Make sure the UI updates correctly after state changes:

// In QuoteBuilder.tsx, ensure useEffect is properly set up

useEffect(() => {
  // Update the total whenever treatments or promo code changes
  const newSubtotal = calculateSubtotal(quote.treatments);
  const newTotal = newSubtotal - (quote.promoDiscount || 0);
  
  // Only update if values changed (prevents infinite loop)
  if (quote.subtotal !== newSubtotal || quote.total !== newTotal) {
    setQuote(prev => ({
      ...prev,
      subtotal: newSubtotal,
      total: newTotal
    }));
  }
}, [quote.treatments, quote.promoDiscount]);
7. Add Error Boundaries
Implement an error boundary to catch and report any issues:

// In a new file ErrorBoundary.tsx
import React, { Component, ErrorInfo, ReactNode } from 'react';

interface Props {
  children: ReactNode;
  fallback?: ReactNode;
}

interface State {
  hasError: boolean;
  error: Error | null;
}

class ErrorBoundary extends Component<Props, State> {
  constructor(props: Props) {
    super(props);
    this.state = { hasError: false, error: null };
  }

  static getDerivedStateFromError(error: Error): State {
    return { hasError: true, error };
  }

  componentDidCatch(error: Error, errorInfo: ErrorInfo): void {
    console.error("Error in component:", error, errorInfo);
  }

  render(): ReactNode {
    if (this.state.hasError) {
      return this.props.fallback || (
        <div className="p-4 bg-red-50 border border-red-200 rounded">
          <h2 className="text-red-600 text-lg font-medium">Something went wrong</h2>
          <p className="mt-2 text-red-500">{this.state.error?.message}</p>
        </div>
      );
    }

    return this.props.children;
  }
}

export default ErrorBoundary;
Then wrap the QuoteBuilder component with this error boundary:

// In the parent component or route
<ErrorBoundary>
  <QuoteBuilder />
</ErrorBoundary>
Implementation Recommendations
To implement these changes, I recommend:

First focus on the applyPromoCode function in use-quote-builder.ts to ensure it properly preserves the treatments array
Add console logging throughout the function to track the state at each step
Test with various promo codes to ensure treatments are never lost
Add the debugging component to visually confirm the state is maintained