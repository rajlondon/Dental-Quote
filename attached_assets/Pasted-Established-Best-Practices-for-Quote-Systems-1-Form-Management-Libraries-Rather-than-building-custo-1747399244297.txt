Established Best Practices for Quote Systems
1. Form Management Libraries
Rather than building custom state management, mature quote systems typically use battle-tested form libraries:

Formik or React Hook Form provide robust validation, field tracking, and state management
These libraries handle the complex state transitions that cause issues in custom implementations
They manage form state in a predictable, optimized way that avoids re-render issues
// Using React Hook Form approach
import { useForm, Controller } from "react-hook-form";

function QuoteBuilder() {
  const { control, handleSubmit, watch, setValue } = useForm({
    defaultValues: {
      treatments: [],
      promoCode: "",
      specialOffer: null
    }
  });
  
  // Watch values to calculate totals
  const selectedTreatments = watch("treatments");
  
  // Apply promo code without losing treatments
  const applyPromoCode = async (code) => {
    // Validate code via API
    const discount = await validatePromoCode(code);
    
    // Set promo code WITHOUT modifying treatments
    setValue("promoCode", code);
    setValue("discount", discount);
  };
  
  // Rest of component...
}
2. State Management Separation
Enterprise quote systems separate concerns clearly:

Product catalog state (treatments, packages) - often cached and rarely changing
Quote state (selections, pricing, discounts) - changes frequently during user interaction
Validation state (errors, warnings) - derived from the above states
This separation prevents the cascading state issues you're experiencing.

3. Immutable State Updates
Commercial implementations use immutable state patterns:

// Instead of directly modifying state
const applyPromoCode = (code) => {
  // Wrong approach - can cause issues with state references
  quote.promoCode = code;
  setQuote(quote);
  
  // Correct approach - create new state object
  setQuote(prevQuote => ({
    ...prevQuote,
    promoCode: code,
    // Don't touch other properties
  }));
};
4. State Machines for Complex Flows
For multi-step quote flows, state machines provide reliability:

Libraries like XState manage complex state transitions
They prevent impossible states (like applying discounts to empty quotes)
They make the flow explicit and testable
5. Optimistic UI with Rollback
Enterprise quote systems use optimistic UI patterns:

const applyPromoCode = async (code) => {
  // Save previous state for potential rollback
  const previousState = {...quote};
  
  // Optimistically update UI
  setQuote(prev => ({...prev, promoCode: code, isValidating: true}));
  
  try {
    // Validate with API
    const result = await validatePromoCode(code);
    
    // Confirm update with actual data
    setQuote(prev => ({
      ...prev, 
      promoDiscount: result.discount,
      isValidating: false
    }));
  } catch (error) {
    // Rollback on failure
    setQuote(previousState);
    setError("Invalid promo code");
  }
};
Implementation Recommendation
Based on industry standards, I recommend:

Adopt React Hook Form for state management - it's designed specifically for complex form scenarios
Create a clear separation between product data and quote state
Use React Query for API data fetching with proper caching
Implement atomic state updates that don't modify unrelated state