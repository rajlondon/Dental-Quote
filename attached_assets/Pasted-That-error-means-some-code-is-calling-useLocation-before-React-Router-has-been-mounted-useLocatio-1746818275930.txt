That error means some code is calling useLocation() before React Router has been mounted.
useLocation (and all the other router hooks) can only run while React is rendering inside a <BrowserRouter> / <HashRouter> / <MemoryRouter> provider. If the hook fires earlier — for example in a module that’s imported at app start-up, in a Zustand store factory, or even in a custom hook that’s executed from outside a routed component — React Router throws the “useLocation may be used only in the context of a <Router>” runtime error, which your error-boundary surfaces as Navigation Error.

How to track it down quickly
1 . Find every use of useLocation
bash
Copy
Edit
grep -R "useLocation(" client/src | cut -d: -f1 | sort -u
Pay special attention to:

Likely culprit	Why it breaks
Custom hooks in src/hooks or src/features that are imported by any file outside a routed component	They run during module evaluation, before <Router> exists
Store initialisers (usePromoStore, useSpecialOfferDetection, etc.)	Same problem: the hook runs as soon as the store file is imported
Utility modules that you now call from both React and non-React code	Non-React code has no router context

2 . Move router-dependent logic into a component that lives inside the Router
Example pattern:

tsx
Copy
Edit
// PromoDetector.tsx
import { useLocation } from "react-router-dom";
import { usePromoStore } from "@/features/promo/usePromoStore";

export const PromoDetector: React.FC = () => {
  const { search } = useLocation();
  const params = new URLSearchParams(search);
  const slug = params.get("promo");

  const setPromoSlug = usePromoStore(s => s.setPromoSlug);

  React.useEffect(() => {
    if (slug) setPromoSlug(slug);
  }, [slug, setPromoSlug]);

  return null; // invisible helper
};
Then mount it once, just under the router:

tsx
Copy
Edit
// App.tsx
import { BrowserRouter, Routes, Route } from "react-router-dom";
import { PromoDetector } from "@/components/PromoDetector";
import YourQuotePage from "@/pages/YourQuotePage";
// ...

function App() {
  return (
    <BrowserRouter>
      <PromoDetector />
      <Routes>
        <Route path="/your-quote" element={<YourQuotePage />} />
        {/* other routes */}
      </Routes>
    </BrowserRouter>
  );
}
Now all router hooks stay inside Router context, and non-router code (stores, util functions) stay pure of React Router imports.

3 . If you really need the location in a store or util…
Pass it in explicitly:

ts
Copy
Edit
// store action
const setPromoFromLocation = (loc: Location) => {
  const params = new URLSearchParams(loc.search);
  set({ promoSlug: params.get("promo") ?? undefined });
};
…and call that action from the PromoDetector component above.

4 . Run a quick smoke-test
pnpm dev

Navigate to /your-quote?city=Istanbul&treatment=dental-implants

No “Navigation Error” should appear; quote page renders with or without a promo ribbon, depending on the URL.

Recap / action list for the Replit agent
pgsql
Copy
Edit
1. grep the repo for useLocation( and identify any files outside routed components.
2. Refactor those pieces: either
   • move logic into a <PromoDetector> helper component inside <Router>, or
   • replace useLocation with window.location if it truly must run outside React.
3. Add the PromoDetector component to App.tsx just under <BrowserRouter>.
4. Verify /your-quote loads without the Navigation Error.
5. Run pnpm tsc --noEmit to ensure no new TS errors were introduced.